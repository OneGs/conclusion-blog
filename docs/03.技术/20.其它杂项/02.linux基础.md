---
title: linux基础
date: 2022-04-07 14:27:31
permalink: /pages/a1cad6/
categories:
  - Linux
tags:
  - 
---
## 查看当前用户
`cat /etc/password`

## 用户格式
```bash
root:x:0:0:root:/root:/bin/bash
ubuntu:x:500:500:ubuntu,,,:/home/ubuntu:/bin/zsh
```
**用户名**：**密码**：**UID**：**GID**：**用户全名**：**HOME目录**：**SHELL类型**

* 用户名：系统的名字，给用户看的，而非机器
* 密码：x，统一为x，密码是加密的，保存在`/etc/shadow`文件。
* UID：机器识别码，用户ID，0：root用户，1~499：系统用户，500~`2*32-1`：普通用户
* GID：用户组ID
* HOME目录：用户文件存储的起始位置，类似`Mac: /User/your_name`
* SHELL类型：用户可自定义，`echo $SHELL`可查看

<!-- more -->

## 查看用户组
`cat /etc/group`

## 用户组的格式
```bash
root:x:0:
ubuntu:x:500:
```
**组名**：**用户组密码**：**GID**：**用户组内的用户名**

用户组内的用户名：在改用户组内的用户将拥有改用户组的所有权限，因此相同的用户可以出现在多个不同的用户组内。

* 用户的创建，更改，删除 `useradd, usermod, userdel`

* 用户权限的设置
`cat /etc/sudoers`通过进入`root`用户，修改`sudoers`文件，达到权限设置。但是必须设置一个进入`root`的入口。更改四种模式：
用户全部权限，用户组全部权限，用户部分权限，用户除此所有权限.
`User/%User_Group ALL=([ALL, /mount /mnt/cdom, ...]) [NO_PASSWORD:ALL, !....]`

* 查看有效用户EUID用户 `whoami`，实际用户UID`who am i`，即权限用户。

## 查看文件或目录信息

`ls -l 文件或目录地址`, 
`目录 drwxrwxr-x 6 ubuntu ubuntu 4096 Feb 23  2019 scrapy`
`文件 -rw-rw-r-- 1 ubuntu ubuntu    8 Aug 28 22:09 tmp`
**文件类型和权限**：**连接数**：**拥有者**：**拥有用户组**：**文件大小**：**最后修改日期**：**文件名**

文件类型：
| 类型 | - | d | l | s |
| --- | --- | --- | --- | --- |
| 描述 | 普通文件 | 目录 | 连接文件 | 套接字文件 |

***SUID**、**SGID**和SBIT三种特殊权限*

读写类型：

| 类型 | w | r | x | s |
| --- | --- | --- | -- | --- |
| 用户权限 | 可写 | 可读 | 可执行（如果是程序） | 可执行（SUID）|

*对于目录，“x”权限可以控制用户是否能够打开它，只有具备“x”权限的用户才能打开这个目录。ls命令来查看这个目录下的文件列表，则必须拥有“r”权限*
*SUID仅对二进制程序有效执行者对于该程序具有x的可执行权限；执行权限仅在执行该程序的过程中有效；执行者将具有该程序拥有者的权限*

## 文件的连接数 [inode](http://www.ruanyifeng.com/blog/2011/12/inode.html)

连接数`inode`表示文件有多少个别名。而`ln`硬连接会增加`inode`数。对于软连接，只是快捷方式不增加`Inode`,源文件一旦删除，别名失效。硬连接，`inode`增加1，同时只要`inode`不为0，无论删除多少其他别名文件都不会影响自身。

文件的`inode`连接数初始值为1，目录的`inode`连接数初始值为2——因为`.`的存在，目录下每有一个子目录`inode += 1`，文件是不增加的。无法对空目录硬链接。由于 inode 号码与文件名分离，这种机制导致了一些 Unix/Linux 系统特有的现象。

1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除 inode 节点，就能起到删除文件的作用。
2. 移动文件或重命名文件，只是改变文件名，不影响 inode 号码。
3. 打开一个文件以后，系统就以 inode 号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从 inode 号码得知文件名。

## 说说你了解的作用于文件的命令，越多越好

| 命令 | 表达式 | 作用 |
| --- | --- | -- |
| vim | `vim temp.txt` | 生成文件并写入数据（无数据，则无法创建）|
| mv | `mv temp.txt temp1.txt` | 改名，移动文件到另外一个地址 |
| chmod | `chmod [ugao][+-=][rwx]` | 改变文件的权限 |
| chown | `chown [-cfhvR] user[:group] file...` | 改变文件的用户组和用户 |
| cd | `cd [. .. / ~ 路径]`| 更改当前目录 |
| cp | `cp ~/temp.txt ~/temp.txt.new` | 制作文件的副本，同一目录下文件名不同 |
| rm | `rm -[ifr] 文件\目录` | i：删除前询问，f：即使原档案属性设为唯读，亦直接删除，无需逐一确认，r：将目录下的内容逐级删除 |
| whereis | `whereis ls/bin` | 用于搜索可执行文件、联机帮助文件和源代码文件，当天新添加无法搜索，除非手动`updatedb` |
| which | `which python` | 用来确认系统中是否安装了指定的软件,在$PATH的路径上找，非实时 |
| find | `find 复杂` | 该命令复杂而强大，搁置 |

*`cp`是创建副本，inode不会增加，是实际的增加了硬盘存储的容量。对于硬连接，虽然inode增加，但文件内容始终只有一份*

## 前后台任务的切换

| 命令 | 创建后台执行 | 改为后台执行 | 查看后台任务 | 调为前台 | 调为后台 | 杀死进程 |
| -- | --- | --- | --- | --- | --- | --- | 
|  | `Command &` | `Ctrl + z` | `jobs` | `fg %标识` | `bg %标识` | `kill -[15(正常), 9（强制）] %标识` |
`nohup Command [ Arg ... ] [　& ]`同样可以后台运行，且中断正常退出也不会终止。不指定输出文件。默认存储在`$HOME/nohup.out`文件

## 设置周期任务

任务的时间设置有定时和周期两种，但定时用的少，所以主要为周期任务，用`crontab`来管理和控制
| 命令 | 编辑 | 查看 | 删除 |file |
| --- | --- | --- | --- | --- |
| `crontab` | `-e` | `-l` | `-r`，会删除全部要注意 | 加载可执行文件 |
参数格式

| 符号 | 分 | 时 | 天 | 月 | 星期 |
| --- | -- | --- | --- | --- | --- |
| 全部 | * | * | * | * | * |
|     | - 从X到Z | / 每过多少个数字| ，散列数字| * 取值范围内的所有数字 |

## 守护进程

守护进程是生存期很长的一种进程。它们独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它们常常伴随着Linux系统启动时启动，关闭时关闭。linux系统有很多守护进程，大多数服务器都是用守护进程实现的。比如负责计划任务的atd和crond、负责打印的lqd。

守护进程由分两种`stand alone` 和 `xinetd`，`stand alone`系统开启时就被加载且全程运行，即占用内存，知道系统关闭而结束。`stand alone`进程的文件被存储在`/etc/init.d`。`Xinetd`是被动激活的，需要配置`xinetd.conf`文件，一般在关联终端时启动，另外，众多的`xinetd`构成`stand alone`并争夺资源。

## 改变环境变量的`shell`语句：`export PATH='变量地址'`

| 文件 | 作用 |
| --- | -- |
| `/ect/profile` | 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. |
| `/etc/bashrc` | 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. |
| `~/.bash_profile` | 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,设置一些环境变量,`source`执行~/.bashrc文件. |
| `~/.bashrc` | 该文件包含专用于用户的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取. |
| `~/.bash_logout` |当每次退出系统(退出bash shell)时,执行该文件. |

*不推荐使用`/etc/profile`设置变量，其包含了开机所需要的信息，如果文件被你损坏，就无法正常开机。推荐使用`~/.bashrc`，针对每个用户`SHELL`的变量，受影响率小，易于维护。*

## bash和Shell的区别

`shell`是命令行解释器和执行器。它是介于使用者和 UNIX/Linux操作系统核心程序（kernel）之间的一个接口，用于计算机和用户间进行交互。

而`bash`是众多`shell`实现的一种，类似的实现由`sh, csh, ksh, zsh`，而`bash`则是从`sh - Bourne shell`进化为`Bourne agian shell`。

总的来说`bash`是`shell`的一种实现，`shell`是为解决人机交互提出的理论。

## 配置环境变量

Linux中的变量有三种，**内部变量**，**用户变量**，**SHELL变量**，

| 类型 | 系统变量 | 用户变量 | `SHELL`变量 |
| --- | --- | --- | -- |
| 行为 | 系统提供，不用定义，不能修改 | 系统提供，不用定义，可以修改,可以利用export将用户变量转为环境变量. | 用户定义，可以修改 |


| 命令 | `set` | `env` | `export` |
| --- | --- | --- | -- |
| 描述 | SHELL变量，用户变量 | 用户变量 | 从SHELL转化为用户的变量 |

对于，内部变量，是系统自定义的变量，相当于C语言中的特殊字面量`int`不能再被命名。用户变量，系统提供了一些目录，`/bin/, /loacl/bin`等，其自动被纳入了变量的范围，只要添加到这些目录下的可执行文件，在终端可直接运行。

`SHELL变量`则是在加载`SHELL`的时候，才被激活的变量。因此如果无法使用可执行文件的话，可以将其转变为用户变量从而可以执行。

首先下载好文件，找到可执行文件。判断可执行文件是否在`echo $PATH`的路径下，如果没有，打开`~/.bashrc`添加`export PATH='可执行文件路径'`，运行`source ~/.bashrc`。运行可执行文件，运行成功。

## 文件系统目录结构

| 目录 | 加载情况 | 作用 | 常用子目录/文件 |
| --- | --- | --- | -- |
| /bin | /bin/bash加载，其它的命令陆续加载 | 加载SHELL需要的系统级命令。系统提供的可执行文件 | `cat wc man ps ls ...` |
| /boot |  | /boot目录下所保存的数据是用于内核开始执行用户级程序之前使用的东西 | abi-4.4.0-130-generic |
| /etc | NULL | 系统特有以及用户的配置文件和目录，即用户控制程序正常运行的文件 | /opt/：/opt下程序的配置文件，/profile：联机加载系统变量，以及一些用户程序配置文件 hosts：主机名静态信息 |
| /home | NULL | /home为用户专有目录，每个用户都会在/home目录下有其对应的子目录。用户程序配置文件是以'.'开头的隐藏文件 | .的隐藏文件；自定义的文件；可执行程序文件... |
| /lib | NULL | 系统的共享库和内核模块，在系统启动和运行根文件系统都需要用到 | libcso.* c动态链接库 |
| /opt | NULL | 系统附加软件包,存放着它所有的可执行程序和静态数据 | NULL |
| /sbin | /sbin, /usr/sbin, /usr/local/sbin | 系统启动、恢复、还原以及修复过程中必备的系统工具，也是对/bin下内容的补充 | `shoutdown, init, fdisl` |
| /tmp | NULL | 临时文件区，能够被任何程序、任何用户访问，切无需负责（建议每次清除） | NULL |
| /usr | ----------- | ---------------------------------| -------------------------------|
| /usr/bin | NULL | 用户级的命令，系统中绝大多数的可执行文件都放置在这里，其文件大多是链接到其它位置，作为别名 | `Python解释器 VIM Perl ...` |
| /usr/include | NULL | C语言的头文件 | iostream.h |
| /usr/lib | NULL | 库和可执行文件，程序可以在这里创建目录，并将相关数据全部关联在该目录下 | python的内置模块文件，XML,random,... | 
| /usr/local | NULL | 程序局域性文件，类似扩展可执行文件，避免程序更新而覆盖 | `pip install 模块`基本就放在/bin下面 |
| /usr/share | NULL | 不同体系结构上运行相同操作系统所共享的文件 | man misc |
| /var | ----------- | 系统中不断变化的文件，如日志文件 | -------------------------------|
| /var/cache | NULL | 内容是来自应用程序的缓存数据，这些内容可以加快那些费时的运算或I/O处理任务 | NULL |
| /var/lib | NULL | 目录保存着那些与某个应用程序或系统有关的状态信息。所谓状态信息，就是程序运行过程中不断修改的那些数据，且仅与具体系统有关 | NULL |
| /var/lock | NULL | 锁文件用于硬件设备和其他被多个应用程序共享的资源 | NULL |
| /var/log | NULL | 运行程序所产生的日志 | NULL |
| /var/mail | NULL | 用户邮箱文件的存放处，所有邮箱文件必须以UNIX邮箱格式存储 | NULL |
| /var/opt | NULL | /opt下软件包的可变数据,子录名称应该与/opt下的子目录名称相一致 | NULL |
| /var/run | NULL | 系统启动开始至当前的系统运行状态信息就保存于此。该目录下的文件，在系统启动进程执行开始，必须被清空 | NULL |
| /var/spoof | NULL | 供以后用的（可以被程序、用户、管理员处理），一旦被处理完毕，就会被删除 | lpd：打印机spoof目录；mqueue邮件待发队列 |
| /var/tmp | NULL | 使得应用程序要求在系统重启期间保护临时文件或目录成为可能 | NULL |

* *三大主要区段 /home /usr /usr/local*

* */bin目录不得包含任何子目录*

* *时下有一种流行的做法是让/boot目录占用一个单独的磁盘分区而与根分区分离。这样能更进一步减小根分区，保护启动分区（完全只读），提高系统的安全性*

* */usr下是只读不可写的，/usr/lib下的文件不被用户和SHELL直接执行，需要被动调用。/usr/local下又存在一个完整的文件系统（都是局部的）。例如bin：可执行文件；etc程序配置文件；lib程序库（pip安装的模块就在此）；man：可执行文件指南；sbin系统管理可执行文件；src源代码*

* *保存在/var/tmp中的数据，比/tmp中的数据得到更多的保护。/var/tmp中的文件或目录，在系统启动时不得删除*

## [文件过滤分割与合并](https://man.linuxde.net/sub/%e6%96%87%e4%bb%b6%e8%bf%87%e6%bb%a4%e5%88%86%e5%89%b2%e4%b8%8e%e5%90%88%e5%b9%b6)

* [cut](https://man.linuxde.net/cut) 选取文件中制定的数据内容，切列
`cut -[bc n][d"分隔符"][f n] filename`
b，c选取第n个字符，f选取第n列，d按分隔符分开，-n从到n，n-从n到EOF，n1-n2从n1到n2。b和cb无法和d一起使用。**当为C时，b失去作用。C是类似链表1-3的形式**。使用用户分割和合并具有标准切相同格式的数据。

* [Sort](https://man.linuxde.net/sort) 文件排序
`sort -[fndr] filename`
f排序时，将小写字母视为大写字母，-r以相反的顺序来排序，-n依照数值的大小排序,-d排序时，处理英文字母、数字及空格字符外，忽略其他的字符.

* [uniq](https://man.linuxde.net/uniq)文件去重并统计
`uniq -[cdu]`
c去除重复，统计累加数；d显示重复，统计累加数；-u仅出现过一次的。

* [head](https://man.linuxde.net/head) Limit限制数量
`head -[-cn n]`
c从0到n个字符，n前n个数。

* [diff](https://man.linuxde.net/diff) 比较文本差异
`diff -[ui] filename filename`
u以合并的方式比较，i忽略大小写

* [tr](https://man.linuxde.net/tr)
`tr -[cds] '第一字符集' ['第二字符集']`
c取代所有不属于第一字符集的字符,求差集；d删除所有属于第一字符集的字符；s将第一字符集中重复字符规约为一个字符；NUll用第而字符集取代第二字符集，两字符集数量相同——‘字符一一对应‘，两字符集数量不同，第二字符集最后一个对应第一字符集剩余所有！

* [wc](https://man.linuxde.net/wc) 获取文件数字统计
`wc -[clw] filename`
c统计有多少bytes, ' '也作为一字节，每一行会有一个换行符占一字节；l统计多少列，以做多的列为准；w有多少个数字。NULL默认**行数、字数，以及字节数**。

* [tail](https://man.linuxde.net/tail)
`tail -[n]`
n读取文件内容的后n条数据

* [join](https://www.runoob.com/linux/linux-comm-join.html) 将两个文件中，指定栏位内容相同的行连接起来
`join -[aeiv]`
a<1或2> 除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行。
e<字符串> 若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。
i或--igore-case 比较栏位内容时，忽略大小写的差异。
v<1或2> 跟-a相同，但是只显示文件中没有相同栏位的行。

* [alias]() 别名

* [unalias]() 取消别名

* [declare]() 声明变量
`declare -[ir] variable_name=[...] / -[fF]`
i设置变量为整数；r变量只读;f显示函数体；F显示函数名；

* [echo]()

* [eval]() 扫描语法量词（复杂扫描）
`eval "ls -l"`
将双引号“”中的字符，替换成标准命令，然后再扫描一次执行命令。再量词臊面的过程中，解析过程，如果没有“”，命令直接执行，有“”，先执行命令在替换字符最后执行命令，利用这点可以惰试的获取变量。

* [exec]()
执行命令完成后退出

* [local]() 局部变量声明，函数体内

* [read]() 从标准输入读取一行到变量
`declare N  read N`
先定义再读取信息，注意：`read`是按行读取的，如果不指定变量，read命令会将读取到的值放入环境变量REPLY中。

* [shift]() 参数偏移
`
until [ -z "$1" ]
do
   echo "$@ "
   shift
Done
`
表示在参数为空之前，一直输出所有参数。
`$0`：当前可执行文件名；`$1,2,3,...`：传入的参数编号；`$@ $*`：所有参数；`$#`：参数的个数。
特殊变量：`$?`：最近脚本执行的返回值。

* [test]()
`test expressioon or [ expression ]`
当使用[ ]的时候，两边一定要空出一格来！成功返回True，错误返回Fasle

* [unset]() 取消变量

* [seq](https://man.linuxde.net/seq) 范围取值
`seq -[fsw]`
f：格式化输出(`%3g`，三个字符，‘ ’填空)；s：用特殊字符分割；w：相同的位数输出99-100,输出099，100。
三种输入格式，`seq n`从1到N；`seq 10 20`从10到20；`seq 10 2 20`从10累加2到20.注意这里是后闭的，即可取最后的值20.
 
 * [for]() 循环语句
`for i in A B C /$(seq 5) /{1..5} `
同样也是单重输入格式，主要说一下`{}`的使用，`{1..5}`作用同`seq 5`，`{1..5..2}`作用同`seq 1 2 5`。`$()`可以帮助运行内部命令。

* [useradd]() 用户添加
`useradd `

* [stat]() 查看Inode信息


## 执行SHELL脚本的方法

1. `source .sh`,不需要可执行权,返回结果则表示*True*,否则为*False*。
2. `. ./.sh bash .sh`同样也可以切不要权限。注意source命令或者点号，不会为脚本新建Shell，而只是将脚本包含的命令在当前Shell执行。

## `SHELL`变量命名注意事项

格式为`variable_name=variable_value`。

1. 赋值号两旁不能留有空格（同测试判断[ ]要留有空格相反）。
2. 当变量中存在空格或者特殊字符时，要用‘’括起来。
3. 变量引用其它变量的值时，要用“”括起来，因为‘’会解析为字符串，不会分析命令。

## bash中的引号

引用是指将字符串用某种符号括起来，以防止特殊字符被解析为其他意思。

Shell中一共有4种引用符，分别是双引号、单引号、反引号（在键盘上和波浪号位于同一个键）和转义符。

双引号又叫“部分引用”或“弱引用”，可以引用除$符、反引号、转义符之外的所有字符；单引号又叫“全引用”或“强引用”，可以引用所有字符；反引号则会将反引号括起的内容解释为系统命令。

强引用可以包含其它的引用符号，而弱引用可以看成内部全是字符串，如果想表示`'`符号，则必须`''\'''`，包裹在弱引用中再转义。

反引用，可以将内部的值直接当做命令执行，类似`$()`，其主要是用来执行命令然后复制给变量。相较于前面两种式作用于变量的。

## bash的逻辑运算符

字符串：`-z:NULL -n:NOT NULL != \< \> =`

数值：`-eq:= -nq:!= -gt:> -lt:< -ge:>= -le:<=`

逻辑判断:`!:非 -a:and -o:or`用于一个判断符[ ]内。`||:or &&:and`用于多个[ ]间。

## 运算

let和$[]两个操作符。let是整数间得运算。注意：等于号和运算符两旁不能出现空格。自增和自减就和C是一样的了！

## 命令模式到编辑模式有哪些操作！

* i:在光标之前输入
* I:在行首进行输入
* a:在光标后进行输入
* A:在行末尾进行输入
* o:在光标下一行进行输入
* O:光标上一行进行输入

##  命令模式>>末行模式

* 输入":"即可（注意所有的命令必须是英文状态下的输入）
* w：保存编辑
* q：退出VIM
* q+!：不保存直接退出VIM。
* wq：保存退出VIM
* s：删除字符后插入
* S：删除当前行后插入
* cw：删除当前单词后插入，适用于“”号内部的数据


## 末行模式>>命令模式

* 输入**Esc**即可

## 光标的移动

* nG：跳动到指定的N行的行首
* G：指向最后一行的行首
* gg：指向第一行的行首
* w：指向下一个字母的字首
* b：指向上一个单词的子首
* e：指向当前字母的子尾
* $：行尾（bash：ctrl+e）
* |：行首（bash：ctrl+a）
* ^：行首词。（即不包含‘’‘\n’等特殊字符）
* g_：行尾词。

## 复制，删除和拷贝

### 命令模式

* yy：复制当前行
* nyy：从当前行开始复制后n-1行
* dd：剪贴当前行
* ndd：从当前行开始剪贴后n-1行
* D：从光标开始剪贴到行尾
* x：删除光标处字符
* X：删除光标前一个字符
* 
### 末行模式：（对应的命令模式）

* 1,yy：yy
* 1,dd：dd

## 撤销和反撤销

* u：撤销
* ctrl+r：反撤销

## 搜索和替换

* /：输入你想要搜索的字符串，n向下查找，N向上查找
* r：按下r，输入替换的单个字符
* R：按下R，从光标开始尽可能多的字符

## 特殊技巧

* `.`：重复上次的命令模式操作
* `N command`：重复N次命令
* `%`：搜索所有类型的括号
* `*`：匹配当前单词在文本中的位置，`*`下一位，`#`上一位
* `:s/old/new` 将当前行中查找到的第一个字符“old” 串替换为“new”
* `:s/old/new/g` 将当前行中查找到的所有字符串“old” 替换为“new”
* `:#,#s/old/new/g`在行号“#,#”范围内替换所有的字符串“old”为“new”
* `:%s/old/new/g` 在整个文件范围内替换所有的字符串“old”为“new”
* `:s/old/new/c` 在替换命令末尾加入c命令，将对每个替换动作提示用户进行确认

## 内核的四大系统
内核分为  进程管理系统 、 内存管理系统 、 I/O管理系统 和文件管理系统等四个子系统。UNIX系统由内核、shell、文件系统和应用程序等4部分组成。















