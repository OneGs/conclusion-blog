---
title: 状态模式
date: 2022-12-07 11:16:54
permalink: /pages/44b97c/
categories:
  - 技术
  - 设计模式
tags:
  - 
---
# 状态模式

## 定义

应用程序的对象可能需要根据不同的情况有不同的行为，我们称之为环境对象。而把影响对象行为的一个或多个因素称之为状态。当有状态的对象和外部事件产生互动时，
其内部状态发生变化，对应的行为也就发生变化。

<!-- more -->

环境类：定义了客户端需要的接口，内部维护一个状态对象，并负责状态的切换。

抽象类：定义一个接口，用以封装环境类中特定状态对应的行为，可以有一个或多个，常见为多个行为。

具体类：抽象类型的具体实现，并且在需要的情况下进行状态切换。

## 解决问题

* 结构清晰，满足单一职责原则。状态切换显示化，减少对象之间的耦合。状态类职责明确，方便扩展。
* 当一个对象的行为取决于它的状态，并且它必须在运行期间根据状态改变行为时，可以考虑使用状态模式。
* 一个操作中存在大量的分支判断，并且这些分支决定于对象的状态时。

## 存在的问题

* 状态模式的使用必然会增加系统的类与对象的个数。
* 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。

## 常见场景

1. 减少分支判断
2. 流程的状态切换

## 实现

现实中，开灯、关灯明显的状态模式，那就来实现一个开关灯。

```typescript
class LigthStatus {
    light: Light;

    abstract switchLight;
}

class OffLightStatus implements LigthStatus {
    light: Light;

    constructor(light: Light) {
        this.light = light
    }

    switchLight() {
        console.log('开灯')
        this.light.setLight(this.light.upLight)
    }
}

class UpLight implements LigthStatus {
    light: Light;

    constructor(light: Light) {
        this.light = light
    }
    
    switchLight() {
        console.log('关灯')
        this.light.setLight(this.light.offLight)
    }
}

class Light {
    private offLight: OffLightStatus;
    private upLight: UpLight;
    public currentLight: LigthStatus;
    
    constructor() {
        this.offLight = new OffLightStatus(this)
        this.upLight = new UpLight(this)
    }
    
    init() {
      this.setLight(this.offLight)  
    }
    
    setLight(light: LigthStatus) {
        this.currentLight = light
    }
}

const light = new Light()
light.currentLight.switchLight()
```

## 区别

* 同“策略模式”

1. 状态模式重点在各状态之间的切换，从而做不同的事情；而策略模式更侧重于根据具体情况选择策略，并不涉及切换。 
2. 状态模式不同状态下做的事情不同，而策略模式做的都是同一件事。例如，聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，但最终做的事情都是支付，也就是说他们之间是可替换的。反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。 
3. 状态模式封装了对象的状态，而策略模式封装算法或策略。因为状态是跟对象密切相关的，它不能被重用；而策略模式通过从Context中分离出策略或算法，我们可以重用它们。 
4. 在状态模式中，每个状态通过持有Context的引用，来实现状态转移；但是每个策略都不持有Context的引用，它们只是被Context使用。 
5. 状态模式将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现，当发现传入参数不是自己这个状态所对应的参数，则自己给Context类切换状态；这种转换是"自动"，"无意识"的。状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。而策略模式是直接依赖注入到Context类的参数进行策略选择，不存在切换状态的操作。 
6. 策略模式的客户端必须对所有的策略类相当了解，明确当前场景下各种策略的利弊，权衡在当前场景下应该使用哪种策略，也就是是说策略类对客户端是暴露的，策略是外界给的，策略怎么变，是调用者考虑的事情，系统只是根据所给的策略做事情。