---
title: TCP的三次握手和四次挥手
date: 2022-04-07 14:52:32
permalink: /pages/45041a/
categories:
  - 前端
  - 计算机网络
tags:
  - 
---

## TCP连接和三次握手的必要性

确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；

1. 首先是客户端发起连接请求。服务端是如何判断该请求为连接请求而不是发送数据或其它请求呢！规定当请求数据中SYN=1，ACK=0，那请求数据即为TCP连接请求。此时还会同步发送一个初始序号seq=x。请求连接数据Seq为随机数。用于之后的判断。

2. 客户端接受到了请求连接报文。首先确认为请求连接的数据。接下来，返回对象的报文。报文内容为：SYN=1，ACK=1，seq=y, ack=x+1.即告诉客户端，你的数据我接受了，并将req增加1（因为数据来了后需要偏转）。

3. 客户端接受响应数据。确认服务器同意连接请求。再发送确认数据，告诉服务端，我要开始发送数据了。发送的报文内容为：seq=x+1,ack=y+1,ACK=1。

4. 此时建立连接，客户端和服务端状态都达到ESTABLISHED。

<!-- more -->

### 三次握手

两次握手不是应该已经可以确立连接了吗？为什么要多此一举三次握手呢！

作用：防止因为网络拥堵而造成的脏请求增加服务端连接开支。

原因：

1. 客户端发送请求连接。

2. 请求连接报文由于网络堵塞导致长时间无法到达服务器。

3. 客户端长时间接受不断服务器响应，重新发送请求连接报文。

4. 请求连接报文通过不同于上一个报文的线路到达服务端。服务端接收到请求，允许建立连接并返回数据。

5. 客户端建立连接完成。发送数据、并断开连接。

6. 此时堵塞路径上的请求连接报文再次到达服务端。（脏报文）

7. 服务端认为客户端又想请求连接。默认同意，并返回同意报文。

8. 此时虽然客户端实际没有请求。但是在服务端看来连接已经建立。（客户端一点都不知道晓）。

9. 服务端等待数据传递。等待客户端断开请求。结果就是造成服务端内存被白白浪费。

如果是三次握手的话，脏请求达到服务器后，服务器响应。客户端因为不知道这次请求，所以不会发送确认报文。服务端也就接受不断，自然无法建立连接。

## TCP的四次分手

断开过程：

1. 客户端主动关闭。发送包文FIN=1,seq=u。

2. 服务器接受到数据。ACK=1，seq=v，ack=u+1。seq为报文开始的序号，ack说明接受到了请求数据。

3. 服务器开始被动关闭。再次发送关闭报文：ACK=1，seq=w，ack=u+1。

4. 客户端接受关闭报文。等待2个MSL时钟。发起最后的关闭请求。ACK=1，seq=u+1，ack=w+1。

全部进入CLOSED状态。

### 为什么客户端最后还要等待2MSL

第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

同样我们用例子来说明：

1. 服务端发起最后一次关闭报文。

2. 客户端接收到到请求。发送最后一次断开请求。启动等待计时器。请求在网络中阻塞了。

3. 服务端迟迟接受不到最后的ack，认为是自己的报文没有达到。再次发送关闭报文。

4. 没有2MSL，此时客户端认为自己已经关闭了。服务端的关闭报文还是接受不到。服务等待一段时间后，再次发送挂关闭报文。

这样就会造成服务端永远都无法关闭，处在LAST_ACK状态，占用内存和端口。

第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器，下一请求不会有旧的请求数据干扰本次请求。

### 关闭请求为什么是四次请求

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。这是因为双方并没有数据需要传输，只是简单的通知对方。

但是在断开过程中，即使客户端发出了FIN请求，只是代表客户端不在发送数据，但不代表网络中的请求报文全部到达服务端，服务端不在的发送响应数据。

因此不能立即断开连接，会先告诉客户端，你发的报文我接受到了，不需要在重新发送。

等待所有请求全部完成后，服务端也正正式发起FIN请求。此时服务端也不在接受请求和发送请求。进入LAST_ACK状态。

最后完成断开。因此之所以是四次，区别在于是否有数据接受和发送。

### TIME-WAIT存在过多的情况

按理说TIME-WAIT只存在于客户端。服务端是如何出现大量TIME-WAIT并影响服务器性能的呢？

比如说存在一个mysql数据库和Nginxweb代理。mysql的默认客户端为3306，nginx为80。

在web程序中，存在一个查询数据库操作。此时当有人请求该操作时，服务器即作为客户端开启一个随机的端口同mysql的3306端口通信。

如果出现有人在利用爬虫，快速访问该接口期望获取不同的数据。由于爬虫本身没有在头部设置keep-alive http请求头部，因此在服务器上会不断开启，断开获取数据。

断开的过程中，客户端需要等待2MSL才会真正关闭，并释放端口和资源。试想一下，1s500次请求，而2MSL一般为2分钟。会造成60 * 500 = 30000个TIME-WAIT。端口无法被释放，内存持续增加，最终导致服务器性能受损，甚至宕机。

解决方案：（这里只说明解决方案，并不说明解决方案带来的负面影响）

* 限制单个IP的请求次数。达到阈值加入黑名单，一段时间后再解除。

* 开启更多端口以供使用！默认0-2^16-1个端口数。但是0-1024被分配给知名的应用。在1024上，还有一些常见的引用端口，例如Mysql的3306，MongoDB的27107等等。当你后期开启端口失败时，可以检测端口是否被占用。

* 调整MSL的时间间隔，调整为20S，那么2MSL就是40S。副作用大，时间越小，副作用越到大。
