---
title: 内存泄露
date: 2022-04-14 16:23:04
permalink: /pages/414b66/
categories:
  - 技术
  - JavaScript常见和难点
tags:
  - 
---

# 内存泄露

硬件的内存资源是有限，当某个变量长期占据内存空间而不被使用时，可以说出现了内存泄露。

js语言中，存在自动回收内存的机制，常见的方式为引用计数。

## GC

语言引擎内有一张表，保存了内存里面所有资源的引用次数，如果一个引用的次数为0，就表示不再用到了，可以将该内存释放。

```javascript
const arr = [1, 2, 3] // 表示一次引用计数
```

上述在代码运行期间一直保持 1 的引用计数，因此不会被清除。除非使用 `arr = null`。

<!-- more -->

## 可能内存泄露的情况

在执行栈内的任务被执行完后，会自动释放任务的作用域，上下文中保存的数据被消除。而全局作用域的伴随整个程序。

因此，内存问题就是，防止全局作用域过多变量，函数作用域能够正常释放。

一般而言，GC会自动回收内存，而无需管理。

但是有时候，代码内维护了一堆死内容，某个时段内存直接爆炸。 GC则认为是正常代码，不自动回收。这个时候需要我们手动完成回收动作。

1. 递归深度较深，且存储变量
2. 将某个对象作为键值对或引用，而对象本身已经消失
3. 意外赋值了全局变量
4. 未及时清理的定时器

* 递归深度较深，且存储变量：

在递归过程中如果存在变量，就会形成新的词法作用域存储该变量。较深层次则会加大开销，导致还未递归完成，程序已经卡死。

要解决这个问题，有两种方案：一、将递归改为循环。二、采用[尾调优化](./08.一等公民function.md#尾调优化)。

* 将某个对象作为键值对或引用，而对象本身已经消失

有时，需要将dom中的node进行保存，待后续使用。但随后node在dom中被移除，而js中人保持者这个node，那该node就是死代码。

这个保存的地方可能是闭包，也可能是全局。解决的方法简单粗暴： 赋值为 null 即可。

* 意外赋值了全局变量

全局变量会伴随着整个程序的生命周期。全局变量的增多无疑是在增加负担，因此要控制全局变量的数量。但总有意外情况。

如：在函数中使用了var。错误的估计了this，导致挂载到window等等。

解决方案是：不要使用var，用let和const替代。弄清除函数的执行上下文。

* 未及时清理的定时器

及时清理定时器即可。
