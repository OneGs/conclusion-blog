---
title: 面试题
date: 2022-05-19 10:49:17
permalink: /pages/30b0b9/
categories:
  - 更多
  - 其它
tags:
  - 
---

# 面试题

## Vue

### 对vue的理解

vue是基于mvvm的渐进式框架。用于实现SPA页面。

最大特点：数据更新自动更新页面，减少dom元素的操作，关注逻辑。

### 对SPA的理解

SPA之前是MPA。

MAP存在闪频，用户体验割裂。

SPA利用改变url而不刷新页面的机制，只更新dom。

前后端分离，提高开发效率。

SPA也存在一些缺点：1. SEO不友好 2. 首屏加载时间过长

### v-if 和 v-show

v-if 对 dom进行操作，有完整的vue生命周期执行。v-show 对 dom 只进行css操作，第一次会执行vue生命周期。

v-show 始终创建执行，v-if 需要为true。

v-if 适合不需要频繁切换的情况，v-show则可以。

### new Vue() 做了什么

1. 初始化变量和需要用到的函数
2. 监听的options中的值，使其动态化
3. 执行$mount，挂载数据
4. render将template转化为vNode
5. update通过diff算法，逐步将vNode转化成真实dom
6. 页面渲染完成

### v-for 和 v-if 为何不能一起使用

v-for 的编译优先级大于 v-if ， 会造成大额的性能开销

解决方案是，数据可能通过computed或created过滤后，再使用！

### PA首屏加载速度慢的怎么解决？

可能的原因：

1. 网络延迟
2. 资源文件过大
3. 资源重复发送
4. 渲染堵塞

因此优化方案如下：

1. 减少入口体积：代码分离、数据懒加载
2. 静态资源本地缓存：启用http缓存、合理利用localStorage
3. UI框架按需加载：如Element配合babel，按需加载
4. 图片资源的压缩：精灵图、体积压缩
5. 组件重复打包：重复的包要单独分离
6. 开启GZip：默认开启GZip
7. CDN加速：部分体积大的第三方库，可采用CDN加速

### 为什么data属性是一个函数而不是一个对象？

vue本身是一个工厂类，需要通过该工厂生产不同的vue类。

同时为了复用 data 等数据都是被挂在原型上，如果使用对象，则形成公用空间，造成组件的污染。

函数则会用一个返回值最为 key 的内容。

### 动态给vue的data添加一个新的属性时会发生什么？怎样解决？

新属性并不会动态监测。

vue所有监测转化在初始化阶段完成，即created之前，beforeCreate之后。

后面的生命周期并不会主动监测了（如果发生更新，会重新观测）。

为此，想要监测。

1. $set
2. 修改最上级的数据，触发递归观测

### Vue组件之间的通信方式都有哪些？

1. props
2. emit
3. vuex
4. eventBus
5. $parent
6. $children
7. $refs
8. attrs 和 listeners
9. provide、inject
10. $root

### nextTick

nextTick用于将代码延后到，当前tick的最后。其解决了多个更新一次触发的问题！

这里说是nextTick，不如是lastTick。

vue通过Promise、MutationObserve、setImmediate、setTimeOut实现异步延后执行。

在Promise内执行callbacks，callbacks记录了所有Watch需要执行的内容。

nextTick则是将值推入callbacks内。

### mixin理解

mixin被用于复用，提高开发效率。包括全局复用和组件复用。

存在明显缺点：调用链过长，代码定位困难。

mixin在vue3中已经被抛弃。

mixin分为：叠加、合并、队列三种新式，知道就好，不深究。

### slot理解

slot被称为插槽。将部分子组件的功能，交给父组件确定和执行。

是父子交互逻辑的一部分。

slot分为三类：

1. 普通插槽
2. 具名插槽
3. 默认插槽
4. 作用域插槽

不同的分类，也只是提供给父组件操作能力的大小。

原理：在render时通过normalizeScopedSlots获得scopedSlots，然后通过t函数执行完成填充！

### key原理

vue patch更新的过程中，会比对新旧node是否为相同节点，进行优化更新。

如果相同则直接替换内容，而不是删除，增加。避免dom开销。

vue 通过判断 key、comment、tagName等来判断是否为同一元素。

在for中，不适用key，则会判断为相同元素，会出现问题。

如：每一行为单选框，现选中第一个，删除第一个，第一个的选中情况还在！

key 同时也能加快diff的对比速度！

### keep-alive

缓存页面。缓存后，不在经过常见的生命周期，而是active和deactive。

有三个常见属性：

1. include：需要缓存的页面
2. exclude：不需要缓存的页面
3. max：最大可缓存的实力

原理：

1. keep-alive通过名称，建立起一个name到instance的映射
2. 切换动态组件过程中，如果需要缓存但没有缓存过，则缓存。否则直接用之前的vNode进行patch（由于keepalive的判断， destory执行但不会销毁）
3. 当keep-alive销毁时，所有缓存的实力都将销毁

### Vue常用的修饰符有哪些

vue修饰符是进一步解放对dom的直接操作，关注逻辑。

表单修饰符：

lazy、trim、number

事件修饰符：

stop
prevent
self
once
capture
passive
native

鼠标修饰符：

left
right
middle

键盘修饰符：

enter、tab、delete等，需要在前面加上@keyup.

### 双向绑定的原理

1. Observe通过defineProperty建立动态关系
2. 如果有watch和computed的话，会进行一次依赖收集
3. 执行render获取vNode的过程，属性值被使用，触发依赖收集
4. 此时，所有依赖收集完成

vue的v-model，会判断Element的类型，选择不同的值进行赋值，同时这个过程中会关闭动态响应

### 生命周期前都做了什么事情，需要注意的是什么

1. beforeCreate：初始化生命周期变量和一些事件函数
2. created：完成所有动态数据的监听，包括data、props、computed、watch等
3. beforeMounted：经过编译或直接获取render函数
4. mounted：执行_update(_render)，正式完成dom的渲染
5. beforeUpdate:  所有的watcher排序完成后（保证父子更新的正确性），实际执行之前
6. updated：当前Watcher执行完before之后，即一个个排队执行（先beforeUpdate，再update），此时内容实际已经更新完毕
7. beforeDestroy：更新过程中遇到removeNode，开始移除Node并执行销毁钩子，此处只是标记要移除了，所有内容还可用
8. destroyed：正式移除，包括从内容和dom上

activated：keep-alive缓存的组件激活时
deactivated：keep-alive缓存组件停用
errorCaptured：捕获来自子孙的错误时

### 自定义指令

钩子：bind、inserted、update、componentUpdated、unbind

绑定值：name、value、oldValue、expression、arg、modify

vNode和oldVNode，但不常用。

一般被用来更改el元素，例如鉴权、防抖等等！

### diff算法

1. 深度优先
2. 同级比较

diff为的是快速比较两颗树的vNode节点存在的差异。

深度优先是指，如果相同则深度比较。

同级比较则是，在两个数组中快速比对不同和相同。

指针法：

1. 开头相同，继续向后移动。最好情况比较完后，某个多余或缺少，则直接删除或增加
2. 开头不相同，从尾部比较，相同则向前移动，最好情况是，前面多出或缺少
3. 新开头和旧尾部相同，旧结尾部移到就开头，并patch复用
4. 新结尾和旧开头相同，旧开头移到旧结尾，并patch复用
5. 四种情况都不满足，从旧的vNode中寻找相同key的vNode进行patch，并将该vNode移到旧开头的前面。没有相同key，则增加vNode

整个patch也经过 patch patchVNode updateChild三个函数一起完成。

其中patchVNode和updateChild形成递归。

### 权限

页面权限：

分静态路由和动态路由，静态路由不需要权限，动态路由则根据权限配置addRoutes。

不存在路由的话，则直接404。无需在beforeEach中频繁判断。

菜单权限：

和页面权限是贯通的，在菜单渲染的同时判断是否拥有该菜单对应的路由权限即可

按钮权限：可以通过自定义指令，方便快捷。

### 跨域解决方案

浏览器有个策略，非同源下的请求数据是非法的。

常见有两种：

1. 后端开放跨域请求host
2. vue proxy代理，原理是用本地启用一个express代理请求



## ES6

### var let const

变量提升
暂时性死区
块级作用域
重复声明
修改声明的变量
使用

### 数组增加的扩展

解构、includes、find、findIndex、from、of、flat、flatMap、fill、copyWidth、keys、values、entries

### 对象增加的扩展

解构、括号表达式、super、assgin、create、keys、for...in、for...of、getOwnPropertySymbols、ownKeys

keys < for...in < getOwnPropertyNames，先便利所有数值键、再字符串键、最后Symbol。

is、setPrototypeOf、getPrototypeOf、values、entries、fromEntries

### 函数增加的扩展

简写、参数默认值、length、name、箭头函数

### Set 和 Map

Set集合，相同值只能存在一次。

add、delete、has、clear、keys、values、entries

Map是Object的增强，允许key为任意值。

set、delete、has、clear、size、get、keys、values、entries、forEach

WakeSet、WakeMap则是对上述得弱引用，不会被引用计数器计数。会被随时回收。

所以无法遍历和size。

### Promise

Promise是解决异步回调地狱的一种方案，最终在微任务队列中执行。

链式操作降低了编码难度。

代码可读性明显加强。

存在三种状态，pending、fullfilled、rejected。对象状态不够外界影响，只能自己改变。且一旦开始则必须成功或失败。

常用的方法：resolve、reject、then、catch、all、race、finally、allSettled

### Generator

generator允许将控制权临时转移到函数外部，并可以接收外部的值继续执行。

常用在延迟执行，异步、协程方面。

yield后的被返回给外部，外部调用可以在next中传入参数，被yield左侧接收。

async await 就是 generator 和 Promise 的语法糖。

### Proxy

用于定义基本操作的自定义行为。属于元编程。

代理，允许代理对象，而不直接操作对象。对应的配套设施是reflect。

常见的handler有：

get、set、has、deleteProperty、ownKeys、getOwnPrototypeDescriptor、
defineProperty、getPrototypeOf、isExtensible、setPrototypeOf、apply、construct

reflect是Object的扩展和迁移，支持proxy所需要的操作。

1. 只要Proxy对象具有的代理方法，Reflect对象全部具有，以静态方法的形式存在
2. 修改某些Object方法的返回结果，让其变得更合理（定义不存在属性行为的时候不报错而是返回false）
3. 让Object操作都变成函数行为

### Module

ES6采用ESM规范导入module，且html原生支持了该module的引入。

module可以做到代码分离，避免污染，重复使用。

支持多种导出和导入模式，也支持从一个文件导入后导出。

import定义在开头，静态编译，利于tree shaking。import()则可以动态导入。

### Decorator

装饰器，算是装饰模式的产物。允许从侧面，在不改变原有函数功能的基础上扩展功能。

代码可读性变量，装饰器命名相当于一个注释。
在不改变原有代码情况下，对原有功能进行扩展。

包含类装饰和函数装饰。

类装饰：两个参数：target。函数装饰：三个参数：target、name、descriptor

如果想要传递参数给装饰器，可利用函数嵌套。


## Css && PerCss

### 盒子模型

分为标准盒子、怪异盒子以及IE盒子。IE盒子被弃用。

标准盒子：styleWidth = content
怪异盒子：styleWidth = border + padding + content

标准盒子总宽度：content + padding + border + height
怪异盒子总宽度：content + height

通过样式可以改变盒子类型：box-sizing: content-box / border-box

### 选择器

元素 属性 类 id / 后代、子选择器、同胞选择器、伪类、伪元素

优先级则根据叠加计算得到结果：分值分别是： A B C D

1. 如果存在内联样式，那么 A = 1, 否则 A = 0
2. B的值等于 ID选择器出现的次数
3. C的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数
4. D 的值等于 标签选择器 和 伪元素 出现的总次数

知道了优先级是如何计算之后，就来看看比较规则：

1. 从左往右依次进行比较 ，较大者优先级更高
2. 如果相等，则继续往右移动一位进行比较
3. 如果4位全部相等，则后面的会覆盖前面的

!important不受分值和inline影响，优先级最高。

可继承的属性：

字体系列、文本系列、元素可见性、表格布局、列表属性、引用、光标属性。

不可继承的属性：

主要是，涉及到元素大小、位置、定位的属性

### em/px/rem/vh/vw

* em：相对于父元素px的大小
* rem: 相对于根元素的大小
* px：像素大小
* vh：高度的百分比大小
* vw：宽度的百分比大小

### 设备像素、css像素、设备独立像素、dpr、ppi

设备像素：
css像素：
设备独立像素：
dpr：
ppi：

### 隐藏页面元素

`display：none`：不占位、无事件、开销大
`visibility`: 占位、有事件、不触发、开销小
`opacity: 1`：占位、有事件、可触发、开销小
`溢出屏幕外`：不占位、有事件、不触发、开销小
`height: 0, width: 0, border: 0`：占位（如果都为0则不占位）、有事件、不触发、开销小

### BFC

渲染规则：

1. 相邻的BFC盒子margin存在塌陷，与方向无关
2. 盒子一个个垂直摆放 
3. 内部盒子总是左外边距和盒子的左内边距接触
4. BFC盒子不会和float元素重合
5. 浮动元素参与BFC盒子的高度计算
6. BFC盒子内元素相互独立互补影响

触发条件：

1. 根节点，即HTML
2. display: flow-root
3. 浮动元素：float值为left或right
4. overflow：设置不为visible，即auto、scroll、hidden
5. display: inline-block、flex、inline-flex、grid、inline-grid、table、inline-table、tab-caption
6. position为absolute或fixed

应用场景：

1. 清除塌陷：利用额外的一层，独立BFC。
2. 清除浮动：浮动不会计算进高度，但BFC可以。
3. 自适应多栏布局：float触发BFC，但仍紧贴左侧。为了让右侧和左侧分离，也将其BFC。这样两者独立。

### 水平垂直居中

水平居中：

1. text-align: center
2. justify-content: center
3. width / margin: 0 auto

垂直居中：

1. height / line-height: 适合当行文本
2. align-items: center

水平垂直居中：

1. 定位 + margin: auto：需要子元素高度和宽度
2. 定位 + margin负值：定位50%，负值自身宽高的50%。需要手动调整高宽比例后的值——不推荐
3. 定位 + transform：定位50%，translate(-50%,-50%)，相较于上述，不需要手动调整，自动适配
4. -------------不定宽、不定高
5. flex布局：align-items 和 justify-content 设置为 center，最简单也最灵活
6. grid布局：同flex设置两个属性即可

### 两栏布局、三栏布局实现方案

1. 两栏布局：

* flex：一个shrink和grow为0，一个为1
* BFC：一个float：left，一个触发BFC（但宽度不能超过100vw，否则换行），最好不要定宽

2. 三栏布局：

* 利用BFC，两边float，中间margin：一个float、一个left、中间的BFC。center需要放在最后
* 两边float，中间float和margin负数：都使用float：left，一个margin-left -100%，一个负自身宽度，需要知道宽度
* 两边absolute，中间margin：两边用width、top、left、right完成定位，center通过margin-left、right露出
* flex：两个为0， 一个为1， space-between
* grid：`grid-template-columns: 100px auto 100px

推荐：BFC、flex、grid

### flex使用场景
